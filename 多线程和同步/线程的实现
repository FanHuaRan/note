线程的实现主要有三种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现
一.使用内核线程实现
  内核线程（Kernel-Level Thread,KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。
  程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process, LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都有一个内核线程的支持，因为只有先支持内核线程才能有轻量级进程。这种轻量级进程与内核线程之间1:1的关系称为一对一的线程模型，如图：

  由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程具有它的局限性：
   1.首先由于轻量级进程是基于内核线程实现的，所以各种线程操作，如创建、析构和同步都需要进行系统调用。而系统调用的代价相对较高，需要在用户态和内核态中进行来回切换。
   2.每个轻量级进程都需要一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持的轻量级进程是有限的。

二.使用用户线程实现(协程)
   广义上说，只要不属于内核线程的线程都叫用户线程。因此在这个定义上轻量级进程也属于用户线程，但轻量级进程与内核线程是一比一的关系，实现始终是建立在内核上的，许多操作都要进行系统调用，效率会受到限制。
   狭义上的用户线程是指完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。用户现场的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快且低消耗的，也可以支持更大规模的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。这种进程与用户线程之间1：N的关系称为一对多的线程模型，如图：

   其实这种线程就是我们常常说的协程！
   使用用户线程的优势在于不需要系统内核的支援，所有的线程操作都需要用户程序自己处理。线程的创建、切换和调度都是需要考虑出的问题，并且由于操作系统只把处理器分配到进程，那诸如“阻塞如何处理”、“多线程系统中如何将线程映射到其他处理器上”这类问题的解决将会异常困难。java、ruby等语言都曾经使用过用户线程，最终又都弃用它。

三.使用用户线程加轻量级进程
   线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的方式。在这种混合实现下、既存在用户线程、也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、西沟等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供的轻量级进程则作为用户线程与内核现场之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的调用要通过轻量级进程来完成，大大降低了整个进程被完全阻塞的风险。这种混合模式下，用户线程与轻量级进程之间的数量比是不定的，即为N：M的关系，所以这又叫多对多的线程模型，如图：
   
   许多UNIX操作系统都提供了N:M的线程模型的实现。