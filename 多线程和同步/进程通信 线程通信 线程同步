总结
	(1)进程是操作系统进行资源分配和调度的基本单元，线程属于进程，是CPU调度和分配的基本单元，进程间可共享所属进程的资源。因此进程与进程之间一般只谈通信，不谈同步，而线程与线程之间既谈同步又谈通信
	(2)线程间的通信目的主要是用于多线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。
	(3)多线程同步或者说线程同步与"同步与异步比较中的同步"不是一个概念：
	   [1]同步就是调用者必须等待被调用者执行完毕后返回才能继续下一步处理
	   [2]多线程同步可以理解为：
		   #一种互斥的方式，当一个对象被一个线程修改的时候，可以阻止另外一个线程观察到内部不一致的状态。
		   #同步还可以保证一系列看似顺序执行的状态转变序列，对象从一种一致的状态变迁到另一种一致的状态。
      简单的说就是多线程同步是为了保证多线程并发执行下不会对资源的访问或者修改出现不一致而对多线程运行进行协调的一种手段，多线程同步与同步有一定相似之处，但不是一个概念。
    (4)7种进程间通讯：管道 有名管道 共享内存 消息队列 信号量 信号 套接字
	   3种线程间通讯：锁机制 信号量 信号
       4种线程间同步：临界区 信号量 互斥量 事件
    (5)关于进程通信，线程通信，线程同步，下面的所有方式只是理论上和大局上的，具体还要区分语言条件来进行说明，比如java的进程间通信就不可以共享内存且java的管道只能用于同一进程的不同线程通信,但java又对这些方式进行了进一步的封装，产生了更多的线程同步类，比如CountDownLatch等等。

原文+小改编
一、进程间的通信方式(IPC,7种)
	(1)管道(pipe):管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
	(2)有名管道(namedpipe):有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
	(3)信号量(Semphore):信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此信号量主要作为进程间以及同一进程内不同线程之间的同步手段。
	(4)消息队列(MessageQueue):消息队列是由消息的链表构成，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
	(5)信号(Signal):信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。
	(6)共享内存(Shared Memory):共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。
	(7)套接字(Socket):套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

二、线程间的通信方式(3种)
	(1)锁机制：包括互斥锁、条件变量、读写锁等
	   *互斥锁提供了以排他方式防止数据结构被并发修改的方法。
	   *读写锁允许多个线程同时读共享数据，而对写操作是互斥的。
	   *条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。
	    条件变量始终与互斥锁一起使用。
	(2)信号量机制(Semphore)：包括无名线程信号量和命名线程信号量
	(3)信号机制(Signal)：类似进程间的信号处理
    线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

三、线程间的同步方式(4种)
	(1)临界区
	临界区是一种轻量级机制，即在某一时间内只允许一个线程执行的代码区域，这个代码区域一般是被互斥锁保护的。
	临界区对应着一个CriticalSection对象，当线程需要访问保护数据时，调用EnterCriticalSection函数；当对保护数据的操作完成之后，调用LeaveCriticalSection函数释放对临界区对象的拥有权，以使另一个线程可以夺取临界区对象并访问受保护的数据。 
	注意:
		[1]关键段对象会记录拥有该对象的线程句柄即其具有"线程所有权"概念，即进入代码段的线程在leave之前，可以重复进入关键代码区域。(重入的概念)
		[2]关键对象对象实际上就是锁
		[3]java当中的互斥锁synchronized和基于AQS的ReetrantLock同步类
	(2)互斥量(Mutex)
	互斥与临界区很相似，但是使用时相对复杂一些（互斥量为内核对象，不仅可以在同一应用程序的线程间实现同步，还可以在不同的进程间实现同步，从而实现资源的安全共享。 
	注意：
		[1]由于互斥量是内核对象，因此其可以进行进程间通信，同时还具有一个很好的特性，就是在进程间通信时完美的解决了"遗弃"问题
		[2]java当中没有互斥量，不过基于AQS可以实现我们的互斥量，AQS作者也给了互斥量的demo,不过这个实现不是内核级别的
	(3)信号量(Semphore)
	信号量的用法和互斥的用法很相似，不同的是它可以同一时刻允许多个线程访问同一个资源，PV操作，同时信号量也属于内核对象，可用于进程间的通信
	(4)事件(Event)
	事件分为手动置位事件和自动置位事件。事件Event内部它包含一个使用计数（所有内核对象都有），一个布尔值表示是手动置位事件还是自动置位事件，另一个布尔值用来表示事件有无触发。由SetEvent()来触发，由ResetEvent()来设成未触发。