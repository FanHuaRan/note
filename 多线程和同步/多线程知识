多线程知识混杂

1.线程同步的方式包括：
（1）临界区（CCriticalSection）：实际上就是加锁的区域（synchronized,Lock等），只能实现线程内同步，不能够用在进程之间
（2）事件机制（CEvent）：事件驱动，不多说
（3）互斥量（CMutex） ：类似于临界区，不过互斥量是在进程间使用，临界区在同一进程的各个线程间使用故效率更高
（4）信号量（CSemphore）:使用个计数器来限制可以使用某共享资源的线程数目（Semaphore等）

2.同步机制应该遵循的基本准则 
· 空闲让进：当无进程处于临界区时，表明临界资源处于空闲状态，允许一个请求进入临界区的进程立即进入临界区，以有效利用临界资源
 · 忙则等待：当已有进程处于临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问
 · 有限等待：对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态
 · 让权等待：当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态

3.可重入函数除了使用自己栈上的变量以外不依赖于任何环境（包括static），这样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。如果确实需要访问全局变量（包括static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。
 简单的说：可重入函数就是可以多线程执行，可以被中断执行，不会发生线程问题的函数，自动变量定义的时候才被创建，函数返回时，系统回收空间，他是的是局部作用域变量，不需要互斥量。可重入函数对全局变量才需要互斥量保护。这儿所谓的自动变量实际上就是局部变量

4.产生死锁的原因主要是：
（1） 因为系统资源不足。
（2） 进程运行推进的顺序不合适。
（3） 资源分配不当等。
产生死锁的四个必要条件：
（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
解决死锁问题的重要算法：银行家算法

5.资源-死锁问题的解决方案：
  哲学家就餐问题。系统中有N个并发进程，若规定每个进程需要申请R个某类资源，则当系统提供K=N*(R-1)+1个同类资源时，无论采用何种方式申请使用，一定不会发生死锁。

6.轮询任务调度与抢占式任务调度的区别
  轮询调度优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度
  抢占式调度实现相对较复杂
  轮询调度算法的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。
   抢占式任务调度允许调度程序根据某种原则去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。抢占方式的优点是，可以防止一个长进程长时间占用处理机，能为大多数进程提供更公平的服务，特别是能满足对响应时间有着较严格要求的实时任务的需求。
	因为抢占式调度可能会暂停一些进程，需要记录进程的运行状态，较为复杂。轮询式只需要轮流分配资源，调度简单。

7.共享型设备是指在一段时间内允许多个进程同时访问的设备

8.无锁化编程有哪些常见方法？
 （1）针对计数器，可以使用原子加
 （2）只有一个生产者和一个消费者，那么就可以做到免锁访问环形缓冲区（Ring Buffer）
 （3）RCU（Read-Copy-Update），新旧副本切换机制，对于旧副本可以采用延迟释放的做法
 （4）CAS（Compare-and-Swap），如无锁栈，无锁队列等待
