CGLIB入门详解
个人理解
(1)CGLIB是一个强大的、高性能的代码生成库。其被广泛应用于AOP框架（Spring、dynaop)中，用以提供方法拦截操作,从而提供动态代理。Hibernate作为一个比较受欢迎的ORM框架，同样使用CGLIB来代理单端（多对一和一对一）关联（延迟提取集合使用的另一种机制）。
(2)CGLIB代理主要通过对字节码的操作，为对象引入间接级别，以控制对象的访问。
(3)CGLIB和jdk代理都是动态代理，在运行期提供增强类的方式
(4)jdk代理只能针对接口+实现类的情况进行代理，jdk代理基于反射机制，每个代理对象内部含有一个委托器，委托器内
   部含有目标对象的引用，对目标对象方法的调用和附加的逻辑都在委托器当中，然后把委托器和代理对象的接口类型数组交给Proxy.newProxyInstance方法，该方法就会通过底层快速的构建一个具有相同接口的代理类对象出来。
   注意：通过jdk代理生成的代理类无法进行反射创建对象，太过于底层，不是传统java语言机制
(5)CGLIB基于ASM库生成字节码实现代理类，其实现原理是构建一个被代理类的子类出来使用，所以不要求被代理类实现接口，但要求被代理类不是final类，否则会ERROR，对于被代理类的final方法，代理类是直接调用，不能够附加其它逻辑
(6)Spring的AOP在Bean实现了接口的情况下，使用jdk代理，在不实现接口的条件下使用CGLIB代理，所以实际上是优先jdk动态代理的，这儿就有个问题，当一个实现了接口的bean在以具体类型进行注入的时候，会报类型不兼容的错误！个人感觉应该以接口声明就使用jdk动态代理，以具体类声明就应该使用CGLIB，但是这样会出现同一个类有多个代理类的实现而导致Bean不好管理的状况
(7)Hibernate的实体类如果是final，则不会为其生成代理，丧失延迟加载等特性
(8)Jdk动态代理使用Java原生的反射API进行操作，在生成类上比较高效；CGLIB使用ASM框架直接对字节码进行操作，在类的执行过程中比较高效(注意：java7之后,Jdk动态代理速度明显提升，两者不相上下)
(9)补充：关于jdk动态代理：http://user.qzone.qq.com/834171100/blog/1502955398
原文
CGLIB(Code Generation Library)详解：https://user.qzone.qq.com/834171100/infocenter