Effective java

第二章 对象的创建和销毁
1.考虑使用静态工厂替代构造函数
   好处：(1)静态工厂方法具有名字，更能表达意图
    	（2)每次被调用的时候，不要求非得创建一个新的对象
    	 (3)可以返回一个原返回类型的子类型的对象
   坏处：(1)类如果不含有共有的或者受保护的构造方法，就无法被子类化
   		 (2)静态工厂与其他构造方法没有任何区别，不会被API文档标识出来

2.通过私有构造方法强化Singleton属性（如果一个类实现了序列化接口，那它就不是严格意义的单例，因为可以被反序列化，后面有解决此方法的途径）

3.通过私有构造函数强化不可实例化的能力
  只包含静态方法和静态域的类虽然有不好的名声（有人滥用来编写面向过程的程序），但是这是有存在价值的：
  (1)可以把操作在基本类型和数组类型上的相关方法组织起来，java.util.Arrays
  (2)可以把操作在实现特定接口上的对象的方法组织起来，java.utils.Collections
  (3)把操作在final上的类的方法组织起来，以取代扩展该类的做法
  (4)工具类，utils，其实上面的都是
  这种类实例化是没有意义的，因此最好将它构造方法私有化，定义成抽象类是不可行的（可以被子类化或者给使用者造成困惑）

4.避免创建重复的对象(字符串和运行时常量池就是这个概念)
  注意：1.除了重用非可变的对象之外，对于那些已知不会被修改的课改变对象也可以使用此方法
  		2.不要滥用，慎重考虑，因为有些情况下会让代码更复杂，且JVM的垃圾回收是很强大的，尽量在重型对象上使用此方法

5.消除过期的对象引用
  java程序虽然存在垃圾回收机制，但是也会存在内存泄露问题（参照示例中的自定义stack）。注意一旦对象的引用过期（不会再使用它），需要清空引用（清空引用可以避免下一次错误使用而不产生空指针异常）
  警惕内存泄露的情况:
  (1)一个类自己管理内存！
  (2)缓存

6.避免使用终结函数
  finalizer通常不可预测，常常比较危险，会导致不稳定行为，更差的性能和移植性问题，应该尽量避免使用析构函数。
  释放资源尽量显示释放
  需要使用终结函数的情况：
  (1)作为安全网
  (2)终止非关键的本地资源(对等体)
  注意如果要使用终结函数，注意子类需要显示调用父类的终结函数，它不像构造方法一样会缺省调用父类的终结方法

---------------------------------------------------------------------------------------------------------

第三章.对于所有对象都通用的方法
7.在改写equals方法时请遵守通用约定
  在如下情况时不改写equals方法：
  (1)一个类的实例本质上是唯一的。比如Thread这种代表活动实体，而不是值的类
  (2)不关心一个类是否提供了"逻辑相等"的测试功能。
  (3)超类已经改写了equals,从超类继承过来的行为对于子类也是正确的。比如HashSet和AbstractSet,ArrayList和AbstractList
  (4)一个类是私有的或者是包级私有的，并且可以确定equals方法永远也不会被调用。这个情况最好还是改写，哪怕就是抛出UnsupportOperationException异常
  如下情况应该改写equals方法
  (1)一个类有自己特有的"逻辑相等"概念，不能使用引用相等来比较
  (2)超类也没有改写equals方法实现上面预期的行为
  改写equals方法的通用约定
  (1)自反性
  (2)对称性
  (3)传递性
  (4)一致性
  (5)对于任意的非空引用值x,x.equals(null)一定返回false 并不需要显示非空值判断
  实现高质量equals方法的处方和步骤
  (1)使用==操作符检查"实参是否为指向对象的一个引用"
  (2)使用instanceof操作符检查"实参是否为正确的类型"，补充还可以做非空值判断，null instanceof class是返回false
  (3)把实参转换到正确的类型
  (4)对于该类中的每一个"关键域"，检查实参中的域与当前对象中的域值是否匹配。域的比较顺序可能会影响性能，先比较最不可能相等的域
  注意事项：
  (1)改写equals方法，总是要改写hashcode
  (2)不要试图让equals方法过于聪明
  (3)不要使equals方法依赖于不可靠的资源
  (4)不要将equals方法中的参数类型从object修改为其它类型，这是重载，不是重写！

8.改写equals方法，总是且必须要改写hashcode
  改写hashcode方法的约定：
  (1)如果一个对象的equals方法做比较所用到的信息没有被修改的话，那么该对象调用hashcode方法多次，必须始终返回同一个整数
  (2)如果两个对象根据equals方法比较是相等的，那么两个对象的hashcode相等
  (3)如果两个对象根据equals方法是不相等的，不要求产生不一样的hashcode,但是如果能不同，有可能能够提升hashtable的性能
   改写equals方法而不改写hashcode方法主要违反了第二条
   实现高质量hashcode方法的处方和步骤
   1.把某个非零常数值保存在一个叫做result的int类型的变量中
   2.对于对象中的每一个关健域f(指equals方法中考虑的每一个域)，完成以下步骤：
   	 (1)如果该域是boolean类型，计算f?0:1;
   	 (2)如果该域是byte、char、short或者int类型，计算(int)f;
   	 (3)如果该域是long类型，则计算(int)f>>>32;
   	 (4)如果该域是float类型，则计算Float.floatToIntBits(f);
   	 (5)如果该域是double类型，则计算Double.doubleToLongBits(f);
   	 (6)如果该域是long类型，则计算(int)f>>>32;
   	 (7)如果该域是对象引用，并且该类的equals方法通过递归调用equals方法来比较这个域，则调用该域的hashcode，如果对象是null，那就为0
   	 (8)如果该域是数组，则依次对数组的每个元素做上述处理
   3.按照下面的公式，把a中的每个域的值组合到result当中
     result=result*31+c;
   4.返回result
   注意：如果一个类是非可变，并且计算散列码的代价比较大，考虑把散列码缓存在对象内部
   		 不要试图从散列码计算中排除掉一个对象的关键部分以提升性能

9.总是要改写toString()
  Object.toString提供了toString的实现：类名:@十六进制hashcode
  一个好的toString实现可以让类使用起来更加愉快，toString方法应该返回对象包含的所有令人感兴趣的信息

10.谨慎的改写clone
   cloneable接口的目的是作为对象的一个mixin接口，表明这样的对象准许克隆，object类本身就含有一个受保护的本地clone方法，在没有实现cloneable接口的情况下，调用clone方法会抛出ClassNotSuppport异常
   clone一定要减少使用，且注意深克隆和浅克隆

11.考虑实现Comparable接口
   一个类如果实现Comparable接口，可以使用Arrays,Collections方法的自然排序，并且和许多泛型方法以及依赖于该接口的集合实现进行协作，在java当中相关排序树TreeMap等都需要依靠此接口
   约定如下：
   (1)必须确保所有的x和y都满足sgn(x.compareTo(y)) == -sgn(y.compareTo(x))。这也暗示着当且仅当y.compareTo(x)抛出异常时，x.compareTo(y)才抛出异常。这条规则和equals使用规范里面的对称性类似。
   (2)必须确保这个比较关系是可传递的：(x.compareTo(y) > 0 && y.compareTo(z) > 0)暗示着x.compareTo(z) > 0也成立。对应着equals使用规范里面的传递性。
   (3)必须确保x.compareTo(y) == 0暗示着所有的z都满足sgn(x.compareTo(z)) == sgn(y.compareTo(z))。
   (4)强烈建议(x.compareTo(y) == 0) == (x.equals(y))，但是这个并非绝对必要。一般来说，任何实现了Comparable接口的类，若违反了这个条件，都应该明确予以说明。推荐使用这样的说法：“注意，该类具有内在的排序功能，但是与equals不一致”。

---------------------------------------------------------------------------------------------------------

第四章 类和接口

12.使类和成员的可访问能力最小化
   (1)一个设计良好的模块会隐藏所有实现细节，把它的API与实现清晰的隔离开来。然后模块之间只通过它们的API进行通信，一个模块不需要知道其它模块的内部工作情况
   (2)经验表明，应该尽可能地使每一个类或成员不被外界访问
   (3)四种修饰符：私有、包级私有(默认)、受保护、共有
   (4)公有域应该尽可能少包含共有的域，有一个例外：通过共有的静态final域来暴露类的常量是准许的
   (5)具有共有的静态final数组域几乎总是错误的
   in a word:应该总是尽可能地降低可访问性

13.支持非可变性
   (1)一个非可变的类是一个简单的类，它的实例的所有域都不可被修改（final）,String、基本类型的包装类、BigInteger,BigDecimal都是非可变类
   (2)为了使一个类成为非可变类，遵循下面5条原则：
      [1]不要提供任何会修改对象字段的方法
      [2]保证没有可被子类改写的方法,一般是使该类成为final类，也有其它做法
      [3]使所有的域都是final的
      [4]使所有的域都成为私有的
      [5]保证对于任何可变组件的互斥访问，对指向可变对象的域，在构造函数，访问方法和readObject方法中使用保护性拷贝。
   (3)非可变对象的很多方法会使用函数式编程的模式，即当前对象上调用的方法不改变当前对象的域，只是返回一个新的对象
   (4)非可变对象本质上是线程安全的，它们不要求同步，可以被自由的共享。非可变类鼓励客户尽可能重用已有的实例，要做到这一点可以提供多个共有静态final常量不可变对象
   (5)不仅可以共享非可变对象，还可以共享它们的内部信息
   (6)非可变对象为其它对象——无论是可变的还是非可变的——提供了大量的构件
   (7)非可变类真正唯一的缺点是：对于每一个不同的值都要求一个单独的对象。可能会代价很高。最好把多步骤操作为基本单元提供或者提供一个包级私有的可变配套类，如String和StringBuilder，BigInteger和BitSet等
   (6)使一个类成为非可变的类，保证没有可被子类改写的方法的其它两个手段：
      [1]让这个类的每一个方法都成为final的
      [2]让所有构造方法成为私有的，或者包级私有，提供一个公有静态工厂
      推荐后者
   (7)为了提高性能可以对非可变类有所放松，延迟初始化
   (8)如果非可变类实现了序列化接口，那么必须提供一个显式的readObject或者readResolve方法进行保护性拷贝,见56
   (9)除非有很好的理由要让一个类成为可变类，否则就应该是非可变的
   (10)如果一个类不能做成非可变类，那么仍然应该尽可能限制可变性
   (11)构造函数应该创建完全初始化的对象，所有约束关系应该在这个时候建立起来

14.复合优于继承
   (1)在一个包的内部使用继承、子类和超类的实现在同一个程序员的控制下、专门为了继承而设计的、具有很好文档说明的类，使用继承是非常安全的
   (2)继承往往导致一个脆弱的类体系
   (3)与方法不同，继承是违反封装性的，而且容易因为设计超类实现细节而导致出错
   (4)复合在很多情况下可以替代继承(代理模式，实现同一个接口，包装一个对象)，也就是复合和转发机制
   (5)只有当子类和超类之间确实存在了类型关系时，使用继承才是恰当的

15.要么专门为继承设计，并给出文档说明，要么禁止继承
   (1)类的文档必须精确地描述了改写每一个方法所带来的影响
   (2)一个类必须通过某种形式提供适当的钩子，以便能够进入它的内部工作流程当中，这样的形式可以静心选择的受保护的方法
   (3)构造函数一定不能调用可被改写的方法，对于实现了Cloneable和Serializable接口，无论是clone还是readObject都不能调用一个可被改写的方法，无论是直接的方式还是间接的方式
   (4)对于为了继承而设计的类实现了序列化接口，必须使readResolve和writeReplace成为受保护的方法，而不是私有的方法
   (5)为了继承而设计一个类，要对这个类有一些实质的限制

16.接口优于抽象类
   (1)接口可以使已有的类很容易的被更新，以实现新的接口
   (2)接口是定义混合类型的理想选择
   (3)接口使得我们可以构造出非层次结构的类型框架
   (4)接口使得安全地增强一个类的功能成为可能
   (5)可以把接口和抽象类的优点结合起来，对于期望导出的重要接口，都提供一个抽象的骨架实现（java8接口默认方法使得这个选择并不是非常重要）
   (6)抽象类的演化要比接口的演化容易得多，当演化的容易些比灵活性和功能更重要时，使用抽象类或者抽象类+接口

17.接口只是被用于定义类型
   常量接口模式是对接口的不良使用
   解决方法：
   (1)把常量放在与常量密切相关的类中
   (2)把常量放在不可实例化的工具类当中

18.优先考虑静态成员类
  



---------------------------------------------------------------------------------------------------------

第五章 C语言结构的替代


---------------------------------------------------------------------------------------------------------

第六章 方法

---------------------------------------------------------------------------------------------------------

第七章 通用程序设计

29.将局部变量的作用域最小化
   (1)将局部变量的作用域最小化，可以增加代码的可读性和可维护性，并降低出错的可能性
   (2)将局部变量的作用域最小化，最有力的技术是在第一次使用它的地方声明
   (3)几乎每一个局部变量的声明都应该包含一个初始化表达式(try/catch除外)
   (4)for循环优于while循环，eg:
        for(Iterator i=c.iterator();i.hasNext();){
            doSomehing(i.next());
        }
      注意：对于支持随机访问的数据结构(数组和使用数组实现的集合)可以使用for迭代+索引访问，对于链表等结构不应该使用这种访问方式，因为会导致平方级的性能损耗。推荐如下方式：
        ArrayList list=.....;
        for(int i=0,n=list.size();i<n;i++){//减少重复调用size方法可以提高速度
            doSomehing(list.get(i));
        }
   (5)使方法小而集中

30.了解和使用库
   (1)通过使用标准库，可以充分利用这些编写标准库的专家的知识，以及前人的使用经验
   (2)在每一个主要的发行版本中，都会有许多新的特性被加入到库中，所以与这些库保证同步是值得的。
   (3)每一个java程序员都应该熟悉java.lang、java.util,某种程度上还有java.io中的内容。
      提一提Collecions Framework集合框架(六大接口：Collection,Set,List,Map,SortedSet,SortedMap,它们不是同级的)

31.如果要求精确的答案，请避免使用float和double.
   more://user.qzone.qq.com/834171100/blog/1505464490
   (1)float和double进行货币计算尤为不合适
   (2)尽量使用BigDecimal(尽量使用字符串初始化)，如果可以自己处理小数点，使用int（小数没有超过9位二进制数字）或者long（小数没有超过18位二进制数字），更大的只能使用bigDecimal
   (3)判断double和float也不能使用==

32.如果其它类型更适合，则尽量避免使用字符串
   (1)字符串不适合代替其它的值类型
   (2)字符串不适合代替枚举类型：类型安全枚举和int值都比字符串更加适合用来表示枚举类型的常量
   (3)字符串不适合替代聚集类型：莫使用字符串拼接，因为解析、处理特别麻烦，最好编写一个类(私有静态成员)
   (4)字符串也不适合替代能力表（即字符串不适合用于对某种功能进行授权访问）

33.了解字符串连接的性能
   (1)个字符串而重复地使用字符串连接操作符，要求n的平方级的时间
   (2)为了获得可接受的性能，尽量使用StrigBuilder(线程不安全)，StringBuffer(依靠synchronized方法实现的线程安全)

34.通过接口引用对象
   (1)如果有合适的接口存在，那么对参数、返回值、变量和域的声明都应该使用接口类型
   (2)如果养成了使用接口作为类型的习惯，那么程序将会更加灵活
   (3)有一点需要注意：如果原来的实现提供了某种特殊的性能，而这种功能并不是这个接口的通用约定所要求的，并且周围的代码又依赖于这种功能，那么很关键的一点是，新的实现（替换的实现）也要提供同样的功能，
   (4)如果没有合适的接口存在，那么，用类而不是接口来引用一个对象，是完全合适的,包括但是不限于以下几个情形：
      [1]值类(String,BigInteger,BigDecimal)直接使用类就OK
      [2]对象属于一个框架，但框架的基本类型是类，这个时候最好使用顶级的基类
      [3]一个类实现了一个接口，但是它提供了接口以外的方法且需要使用
    
    一句话：使用接口来引用对象的程序会更加灵活，如果不能通过接口引用，则使用类层次结构中提供了所需功能的最高层的类

35.接口先于映像(反射)机制
   (1)反射机制的坏处：（1）损失了编译时类型检查的好处
                    (2)要求执行映像访问的代码非常冗长
                    (3)性能损失
   (2)通常，普通应用在运行时刻不应该以映像方式访问对象
   (3)如果只是在很有限的情况下使用映像机制，那么虽然也会付出些许代价，但可以获得更大的好处
   (4)以映像方式创建对象，然后通过使用它们的接口或者超类以正常方式访问这些实例是比较nice的
   补充：对于类浏览器、对象监视器、代码分析工具、内嵌的解释器系统、框架实现（Springmvc、AOP），jdk代理等情况不得不使用反射

36.谨慎地使用本地方法
   尽可能少用本地方法，因为现代jvm足够快，并且使用本地方法有以下几个缺点：
   (1)本地方法不够安全
   (2)本地方法移植性比较差
   (3)调用和退出本地方法开销较大
   (4)本地代码的一个bug甚至可以终止jvm

37.谨慎地进行优化
  (1)不要因为性能而牺牲合理的结构，努力编写好的程序而不是快的程序
  (2)努力避免那些限制性能的设计决定
  (3)考虑API设计决定的性能后果
  (4)为了获得好的性能而对API进行曲改是非常不好的想法
  (5)每次试图做优化前和之后，请对性能进行测量
  一句话：设计的时候好好设计，努力提升性能和扩展性，后期尽量不为提升性能进行优化，可以重构！

38.遵守普遍接受的命名惯例
  不总结了，空间有日志，注意包的命名最好对单词使用缩写，不要太长！

---------------------------------------------------------------------------------------------------------

第八章 异常
39.只针对不正常的条件才使用异常
   异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。
   一个设计良好的API不应该强迫它的客户为了正常控制流而去使用异常。
   两种状态相关方法异常相关的设计方法：
   (1)状态测试方法，Iterator.next&Iterator.hasNext
   (2)可被识别的返回值，如null等
   指导原则：
   (1)如果一个对象会在缺少外部同步的情况下被并发访问，或者可以被外界改变状态，使用可被识别的返回值，因为并发当中状态可能改变了。
   (2)如果一个单独的状态测试方法必须要重复状态相关方法的工作，使用可被识别的返回值
   (3)其它情况为了可读性，优先使用状态测试方法。

40.对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常
   三种可抛出和捕获的结构：被检查的异常(Checked exception)、运行时异常(runtime exception)和错误(Error)
   选取原则:
   (1)如果期望调用者能够恢复，那么，对于这样的条件应该使用被检查的异常(API设计者让API用户面对一个检查型异常是在——提示用户与异常相关联的条件是调用这个方法的一种可能的成果，强制要求用户能从这个异常条件当中恢复，用户也可以捕获后直接忽略，不过这样不太好)
   (2)有两种未被检查的可抛出结构：运行时异常和错误，在行为上两者是等同的，都是不需要且不应该被捕获的抛出物！如果一个程序抛出运行时异常或者错误，往往这种情况是不可恢复的，继续执行有害无益！
   (3)使用运行时异常来指明程序错误(大部分运行时异常是明白前提违例，即API用户没有按规定使用API,这种一般是程序错误)
   (4)错误一般被JVM保留来用于指示资源不足，约束失败或者其他程序无法继续执行的条件，所以不要使用错误，自定义的未被检查的抛出结构应该是RuntimeException的子类。
   总之对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常，检查型异常最好包括相关获取异常信息的辅助方法。

41.避免不必要的使用被检查的异常
	对于检查型异常，如果正确使用API仍然会抛出异常且一旦产生了异常可以采取有用的动作，那么这对于程序员的负担是正常的，如果这两个条件不满足，那么选择使用运行时异常。
	把被检查的异常变成未被检查的异常的一种技术：把这个要抛出的异常的方法分成两个方法，其中一个方法返回boolean表明是否应该抛出异常。这是一种API转换，虽然可能不太合适，不过会让API用户更方便，参考39的状态测试。

42.尽量使用标准的异常
   java平台库提供了一组基本的未被检查的异常，它们覆盖了绝大多数API抛出异常的需要，我们尽量重用已有的异常。
   重用现有的异常的作用:
   (1)使API更加易于学习和使用，因为和我们一贯用法一致。
   (2)可读性更好，都是熟悉的异常
   (3)异常类越少，内存占用越小，装载这些类的时间的开销也更小，
   常用的非运行时异常：
	(1)IllegalArgumentException：参数非法
	(2)IllegalStateException：对于这个方法调用而言，对象状态不合适
	(3)NullPointerException: 在null被禁止的情况下参数值为null
	(4)IndexOutOfBoundException:下标越界
	(5)ConcurrentModifycationException:在禁止并发修改的情况下，对象检测到并发修改
	(6)UnsupportedOperaionException:对象不支持客户请求方法

43.抛出的异常要适合于相应的抽象
	高层的实现应该捕获低层的异常，同时抛出一个可以按照高层抽象进行解释的异常,这被称为异常转译(注意并不是总是适用)。
	一般套路：
	try{
		低层方法
	}catch(低层异常 e){
		throw new 高层异常;
	}
	最好使用异常链:
	try{
		低层方法
	}catch(低层异常 e){
		throw new 高层异常(e);
	}
	尽管异常转译比不加选择地传递低层异常的做法有所改进，但是它也不能被滥用，
	注意：底层应该尽量保证异常不产生，如果无法阻止底层的异常，让高层来处理异常，从而将高层方法的调用者，与低层的问题分开，异常抛出的两个指导意见：
	(1)如果既不能阻止来自底层的异常，也无法将他们与高层隔离开，使用异常转译。
	(2)底层所抛出的异常对于高层也是合适的，可以将异常传递到高层。

44.每个方法被抛出的异常都应该有文档
   多看看jdk源码就明白了，还是记下来
   (1)总是要单独地声明被检查的异常，并且利用javadoc的@throws标记，准确记录下每个异常被抛出的条件(包括检查型饿运行时)
   (2)使javadoc的@throws标签记录下一个方法可能会抛出的每个未被检查的异常，但是不要使用throws关键字将未被检查的异常包含在方法的声明中
   (3)如果一个类中的许多方法由于同样的原因而抛出同一个异常，那么在该类的文档注释中堆这个异常做文档，而不是为每个方法做文档是可以接受的。

45.在细节信息总包含失败-捕获信息
   重写toString方法，让其包含错误信息，从而可以让编译器自动打印出错误信息
   //实际上Throwable基类已经重写了toString方法可以打印一些细节，
   //对这个不满的时候，我们直接对其进行改写。
      public String toString() {
        String s = getClass().getName();
        String message = getLocalizedMessage();
        return (message != null) ? (s + ": " + message) : s;
    }

46.努力让失败保持原子性
  一般而言，一个失败的方法调用应该使对象保持在"它被调用之前的状态"，具有这种属性的方法被称为具有失败原子性。
  个人感觉就是ACID中的A原子性，C一致性
  获得失败原子性的途径：
  (1)设计不可变对象
  (2)在可变对象上，在执行操作之前检查参数的有序性，使得对象状态修改以前，异常就被抛出
  (3)对计算处理过程调整顺序，使得任何可能会失败的计算部分都发生在对象状态修改之前。
  (4)编写一段恢复代码，不常用，主要用于永久性的数据结构
  (5)在对象的临时拷贝上执行操作，当操作完成时，将临时拷贝的结果复制给原来的对象，eg:Collections.sort
  尽量让失败保持原子性，虽然还是有很多API没办到，办不到也要在文档中进行说明

47.不要忽略异常
   空的catch块会使异常达不到应有的目的，至少catch块也应该包括一条说明，用来解释为什么忽略掉这个异常是合适的。
   catch中尽量处理异常，在有足够的理由可以不管这个异常时，加一条说明。

---------------------------------------------------------------------------------------------------------
	
第九章 线程
48.对共享可变数据的同步访问
   同步的理解：
   (1)一种互斥的方式，当一个对象被一个线程修改的时候，可以阻止另外一个线程观察到内部不一致的状态。
   (2)同步还可以保证一系列看似顺序执行的状态转变序列，对象从一种一致的状态变迁到另一种一致的状态。
   简单的说，无论何时当多个线程共享可变数据时，每个读或者写的线程必须获得一把锁。（读与读之间不用同步，读与写，写与写之间必须互斥）
   补充：在单例当中，双重检查往往不能很好的工作，因为可能另外一个线程会或取到一个不完整的对象，最好直接初始化或者使用内部类！

49.避免过多的同步
   (1)为了避免死锁的危险，在一个被同步的方法或者代码块当中，永远不要放弃对客户的控制：在一个被同步的区域内部，不要调用一个可被改写或者受保护的方法(这样的方法往往是抽象的)，该同步区域不知道这个方法会做什么事情，因此极有可能引起死锁。
   (2)在同步区域之外被调用的外来方法叫做开放调用，可以避免死锁和增加并发性。
   (3)通常，在同步区域内做尽可能少的工作。一般就是获得锁，检查共享数据，根据需要转换数据，释放锁。如果必须执行耗时的工作，考虑把该动作移到同步区域外(个人感觉本地IO操作是个例外)

50.永远不要在循环的外部调用wait
	Object.wait方法用于在同步块当中使一个线程等待某个条件。下面是使用wait方法的标准模式：
	Synchronized(obj){
		while(等待条件|不能持有锁的条件){
			obj.wait();
		}
		//////do some thing
	}
	总是使用wait循环模式来调用wait方法，永远不要在循环的外部调用wait，循环被用于在等待的前后检查条件(个人感觉wait调用无条件就不用了while了，或者作者是想让我们调用wait一定要检查条件？)，
	下面的理由会让一个线程醒过来：
	(1)另外一个线程可能得到了锁，并且在该线程调用notify的时刻，在等待线程醒过来的时刻之间，得到锁的线程已经改变了状态
	(2)条件并没有成立，但是另外一个线程恶意的调用了notify方法，这通常是公共锁！
	(3)通知线程在唤醒等待线程时可能过度大方，比如即使只有某一些等待的线程的条件已经被满足，但是通知线程还是必须调用nofityall
	(4)在没有被通知的情况下等待线程也可能醒过来，伪唤醒。
	(5)wait超时或者被interrupt后竞争到了线程锁，后者会抛出InterruptException.

	相关话题：为了唤醒正在等待的线程，应该使用notify还是notifyAll?
	(1)假设所有的wait调用都在while循环的内部，使用notifyAll是合理而保守的选择，程序总是能保证正确的结果，因为有循环检查保证正确性
	(2)一种优化措施，如果处于等待状态的所有线程都在等待同一个条件，而每次只有一个线程可以从这个条件中被唤醒，那使用notify.
	(3)无论何种情况，调用notifyall都是有意义的，就好像把wait放在循环条件中一样，notifyall可以避免相关线程的意外或者恶意等待，这种线程会吞掉唤醒通知，使得真正等待的线程一直等待，所以我们尽量使用内部私有锁。
	(4)使用notifyAll不会影响正确性，但会影响性能。会把等待线程数的线性级退化到平方级，假设有N个线程等待唤醒，那么notify一般就是唤醒N次。而notifyAll需要唤醒n+n-1+n-2+...+1次。
	(5)承接4.如果等待的线程数过多，此情况必须考虑效率，或者竞争某个特定状态的所有线程的逻辑是等价的，那就需要使用notify来精心设计唤醒策略

	总结：总是在while循环内部使用wait,使用notifyall可以保证正确性，但是会降低性能，使用notify可以提升性能，但是需要好好进行设计。

51.不要依赖于线程调度器
	当有多个线程可以运行时，线程调度器决定哪个线程将会运行，以及运行多长时间，线程调度器是jvm底层的组件。
	任何依赖于线程调度器而达到正确性或者性能要求的程序，很有可能是不可移植的。
	编写健壮，高性能的多线程程序是确保任何给定时刻只有少量的可运行线程。（多依靠wait,notifynotifyall，而不让线程忙等性能会更高）
	不要企图使用Thread.yield来"修正程序”，对于大多数程序员来说Thread.yield的唯一途径是测试期间人为的增加一个程序的并发性，对找出微妙的并发错误很有帮助
	线程优先级是最不可移植的特性，通过调整线程的优先级改善应用程序的响应能力，并非不合理，但这是不必要的。
	简单来说，不要让程序的正确性依赖于线程调度器。

52.线程安全性的文档化
	需要在一个类的文档中描述它的行为的并发性情况，如果不这样做，客户端可能会缺少足够的同步，或者过多的同步
	一个类为了可被多个线程并发的调用，必须在文档当中清楚的说明其所支持的线程的安全性级别。
	类的安全性级别如下：
	(1)非可变
	(2)线程安全
	(3)有条件的线程安全，比如HashTable和Vector的方法线程安全，但是他们的迭代器要求外部同步
	(4)线程兼容，在方法调用的外部使用同步可以确保线程安全，比如ArrayList和HashMap
	(5)线程对立，该类不能被安全的在多个线程中并发调用，即使外部加了锁，通过情况下是这个类的方法需要修改静态数据，而该静态数据可能会影响其它线程，这种情况非常少，比如System.runFinalizerOnExit

53.避免使用线程组
   线程组(ThreadGroup)是一个基本的抽象，可以统一管理一组线程，但是没有提供多少实用的功能，或者带来任何的提升安全性的作用。线程组基本已经过时。如果需要考虑使用线程组，那么使用数组或者集合代替可能更好。
   有一个例外，如果想统一给一组线程设置异常处理：ThreadGroup.unCaughtException会有很多作用、

---------------------------------------------------------------------------------------------------------

第10章 序列化
54.谨慎的实现Serializable
   (1)实现Serializable的最大代价是一旦一个类被发布，则"改变这个类的实现"的灵活性大大降低。
   (2)实现Serializable的第二个代价是增加了错误和安全漏洞的可能性。注意：序列化反序列化机制是一种语言之外的对象创建机制，不会经过构造函数。
   (3)实现Serializable的第三个代价是随着一个类的新版本的发行，相关的测试负担增加了。
   (4)实现Serializable接口不是一个很轻松就可以做出的决定。
   (5)为了继承而设计的类应该很少的实现Serializable,接口也应该很少会扩展序列化接口。(有些情况下违反这条规则是合适的)
   (6)对于为了继承而设计的不可序列化的类，应该考虑提供一个无参数的构造函数
   简单的说：实现Seriallizable接口很不容易

55.考虑使用自定义的序列化方式
   (1)若没有认真考虑默认序列化形式是否合适，则不要接受默认序列化形式
   (2)如果一个对象的物理表示等同于它的逻辑内容，则默认的序列化可能是合适的。
   (3)即使你确定了默认序列化是合适的，通常仍需要提供一个readObject方法以保证约束关系和安全性
   (4)当一个对象的物理表示与它的逻辑数据内容有实质性的区别时，使用默认序列化形式有4个缺点：
      [1]它使这个类的导出API永久地束缚在该类的内部表示上
      [2]要消耗过多的空间
      [3]要消耗过多的时间
      [4]会引起栈溢出
      特别是对于Map或者链表等结构而言，需要将其链表节点标注为transient,然后先写size->挨个写值
   (5)如果所有的实例域都是transient的，那么从技术角度而言，省去调用defaultWriteObject和defaultReadObject也是可以的，但是不推荐这样做
   (6)在决定将一个域做成非transient之前，请一定要确信它的值将是该对象逻辑状态的一部分
   (7)不管你选择了哪种序列化方式，你都要为自己编写的每个可序列化的类声明一个显示的序列化版本UID
   in a word:只有当默认的序列化形式能够合理的描述对象的逻辑状态的时候，才使用默认的序列化方式，否则就设计一个自定义的序列化形式，通过它合理的描述对象的状态

56.保护性的编写readObject方法
   (1)readObject中除了自定义的序列化，还有两件事需要做：
     [1]维护约束性条件
     [2]保护性拷贝
   (2)当一个对象被反序列化的时候，对于客户不应该拥有的对象引用，如果哪个域包含了这样的对象引用，则必须要做保护性拷贝，这是非常重要的（攻击者可以在序列化字节流的背后加上对象引用指向那些私有对象字段的值，从而在外部改变对象内部字段的值)
   (3)保护性拷贝是在有效性之前进行检查的  
   (4)编写健壮的readObject方法应该遵循的原则：
     [1]对于对象引用域必须保持为私有的类，对"将被保存在这些域中的对象"进行保护性拷贝。非可变类的可变组件就属于这一类别
     [2]对于具有约束条件的类，一定要检查约束条件是否满足，如果不满足，则抛出一个InvalidObjectException异常，这些检查动作应该跟在所有保护性拷贝之后。
     [3]如果在对象图被反序列化之后，整个对象图必须都是有效的，则应该使用ObjectInputValidation接口(下来补充)
   (5)无论是直接方式还是间接方式，都不要调用类中可被改写的方法

57.必要时提供一个readResolve方法
   (1)如果一个类实现了序列化接口，那么它就不是一个单例，除非一个readResolve方法
   (2)readResolve方法用于在反序列化对象之后替换成我们自己的对象，反序列化的对象会直接被忽略，随后会被GC回收掉.(注意这个readResolve实际上是在反序列化对象上面调用的)
   (3)readResolve方法不仅仅对于singleton对象是必要的，而且对于所有其它的实例受控的类也是必需的。
   (4)readResolve方法的第二个用法是作为保护性的readObject方法的一种保守的替代选择(56条)，此种方法可以保证反序列化的约束性不被破坏，不过会有性能损失和更大的开销。eg:
      private Object readResolve() throw ObjectStreamException{
          return new Period(start,end);
      }
   (5)尽管保护性readResolve模式并没有被广泛使用，但是它值得认真考虑。
   (6)readResolve方法的可访问性是非常重要的。
