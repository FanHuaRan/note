1.网络I/O模型有两个判断标准：是否阻塞，同步还是异步，这两个标准是两回事互相并不冲突
2.以read操作为例：
  read的具体操作分为以下两个部分(可以参考：http://www.cnblogs.com/charlesblc/p/6202402.html):
　　（1）内核等待数据可读(实际的数据到达是由操作系统完成的)
　　（2）将内核读到的数据拷贝到进程（用户态）
  当用户进程阻塞在了等待数据可读的阶段，即为阻塞，不阻塞在该阶段即为非阻塞
  当用户进程将内核数据拷贝到进程，即为同步，当内核主动将内核数据拷贝到进程的缓冲区即为异步
3.针对第二条不难得出结论：判断是否是block的依据是用户进程是否block在等待数据阶段，判断是同步还是异步的依据是把数据从内核态复制到用户态是内核主动还用户进程主动
4.常见IO模型有如下几种：同步阻塞模型、同步非阻塞模型、IO多路复用模型、异步非阻塞模型
  同步阻塞模型、同步非阻塞模型、IO多路复用模型均为同步，
  异步虽然是在第二个步骤才区分，不过只要是异步之间区分阻塞和非阻塞已经没有意义，异步肯定是非阻塞的
  IO多路复用模型有人叫它异步阻塞模型，这是错误的，它实际上是同步的（进程主动去内核取数据），在第一步是没有阻塞的，究其原理是通过select机制进行的，可以理解为一种特殊的同步非阻塞模型
5.IO多路复用的核心Reactor模式
  异步非阻塞IO的核心Proactor模式是
6.java BIO包是同步阻塞模型，NIO包是多路复用模型，NIO2(AIO)包异步非阻塞模型
7.关于非阻塞同步模型，它实际上是检测是否可读，如果不可读就会直接返回，后面的绝对不再执行，因此需要使用用户进程需要使用轮训去判断是否可读！！恼火的东西