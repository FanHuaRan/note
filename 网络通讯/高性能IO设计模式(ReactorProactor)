核心要点
1.Reactor模式叫做IO多路复用（有些人叫它异步阻塞，实际上这是错误的，IO多路复用设计上在read第二步操作是同步进行的）
  Proactor模式是异步非阻塞IO
2.read操作具体有两个步骤，第一个步骤区分是否阻塞，第二个步骤区分同步或者异步
3.判断是否是block的依据是用户进程是否block在等待数据阶段，判断是同步还是异步的依据是把数据从内核态复制到用户态是内核主动还用户进程主动

在学习这两个设计模式之前需要明白网络I/O的一个重要知识
网络IO操作实际过程涉及到内核和调用这个IO操作的进程(或线程)。
read的具体操作分为以下两个部分(可以参考：http://www.cnblogs.com/charlesblc/p/6202402.html):
　　（1）内核等待数据可读(实际的数据到达是由操作系统完成的)
　　（2）将内核读到的数据拷贝到进程（用户态）
write的具体操作分为两个部分（还有点疑惑）
     (1) 将进程或者线程的数据（用户态）拷贝到内核
     (2) 在拷贝的同时，操作系统内核就会发送数据，拷贝完发送差不多也结束
 以read操作为例：当用户进程阻塞在了等待数据可读的阶段，即为阻塞，不阻塞在该阶段即为非阻塞
 				 当用户进程将内核数据拷贝到进程，即为同步，当内核主动将内核数据拷贝到进程的缓冲区即为异步

Reactor模式和Proactor模式是基于事件驱动的I/O设计模式，在网络编程中比较常用。
其中Reactor模式是一种同步I/O模式，其实现是众所周知的 I/O 多路复用，
	Proactor模式是一种异步I/O设计模式，其实现是出名的异步非阻塞I/O，这个必须依靠操作系统内核的支持！

Reactor模式
	
Reactor模式应用于同步I/O的场景。我们以读操作为例来看看Reactor中的具体步骤：
读取操作：
1. 应用程序注册读就绪事件和相关联的事件处理器
2. 事件分离器等待事件的发生
3. 当发生读就需事件的时候，事件分离器调用第一步注册的事件处理器
4. 事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理


Proactor模式

读取操作：
1. 应用程序初始化一个异步读取操作，然后注册读取完成事件和相应的事件处理器（注意：此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键！）
2. 事件分离器等待读取完成事件
3. 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点，Proactor中，应用程序需要传递缓存区。
4. 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。
Proactor中写入操作和读取操作也一样，只不过感兴趣的事件是写入完成事件。


从上面可以看出，Reactor和Proactor模式的主要区别就是真正的读取和写入操作是由谁来完成的，Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备.
判断是否是block的依据是用户进程是否block在等待数据阶段，判断是同步还是异步的依据是把数据从内核态复制到用户态是内核主动还是用户进程主动，所以Reactor模式是同步，Proactor模式是异步
