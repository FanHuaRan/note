递归和动态规划解决汉诺塔问题算法题
什么是汉诺塔问题？
    问题阐述：
    现有三座塔，A塔上按照从小到大、从上到下的顺序放着n个盘子，B塔和C塔上有没有任何盘子，如何将这n个盘子从A塔移动到C塔？移动过程和移动结果都要保证从小到大、从上到下的顺序，只能依靠这三座塔。
    问题解法：
    这是一个标准的递归问题：
    假设起点为to,终点为from,中间塔为pass,盘子数为n,伪代码如下：
    move(n,from,to,pass){
       if(n==1){
          //直接移动
       }else{
          //移动上面的n-1个盘子到中间塔
          move(n-1,from,pass,to)
          //直接移动第n个塔到目标塔
          ....
          //将中间塔上的n-1个盘子移动到到目标塔
          move(n-1,from,to,pass)
       }
    }
    算法分析：
    算法复杂度为O(2^n),实际上最终的移动步数就是2的n次方-1，不得不感叹递归的精妙

递归和动态规划解决汉诺塔问题算法题
    问题描述：
    有一个int数组arr其中只含有1、2和3，分别代表所有圆盘目前的状态，1代表左柱，2代表中柱，3代表右柱，arr[i]的值代表第i+1个圆盘的位置。比如，arr=[3,3,2,1]，代表第1个圆盘在右柱上、第2个圆盘在右柱上、第3个圆盘在中柱上、第4个圆盘在左柱上。如果arr代表的状态是最优移动轨迹过程中出现的状态，返回arr这种状态是最优移动轨迹中的第几个状态。如果arr代表的状态不是最优移动轨迹过程中出现的状态，则返回-1。
    给定一个int数组arr及数组的大小n，含义如题所述，请返回一个int，代表所求的结果。
    问题分析：
    首先这不是一个简单的汉诺塔问题，简单的说我们就是有一个利用汉诺塔法则移动了不知道多少步的盘子的现状，我们要求出要移动多少步能够到这个现状。
    很容易想到的就是按照标准汉诺塔问题的算法，在每次移动一步时，都进行比较，并且使用一个参数记录步数。这种算法有两个弊端：
    1.需要的时间复杂度是O(2^n)
    2.当前问题给提供的数据结构也不便于进行这种算法，因为涉及数组的线性查找
    有没有更精妙的解法：
    动态规划可以解决这个问题！我们继续分享这个问题，一个int数组arr记录了当前盘子的分布状况，盘子大小就是索引大小，我们现在只知道两点：
    1.汉诺塔问题当中，如果第i个盘子被移动到了目标位置，后续再也不会移动它，这就意味着arr[i]再也不会改变
    2.汉诺塔问题移动n的盘子需要的次数是2的n-1次方
    于是我们可以按照盘子从大到小的顺序进行反向递推，实际上就是一个动态规划，经过分析，有如下动态规划公式：
    假设f函数代表求将k个盘子从from移动到to情况下，移动到arr状态下需要的次数，为了计算方便，k从0开始
    f(arr,k,from,to,pass)=f(arr,k-1,to,pass,from);当arr[k]==from时
    					  全部-1;                 当arr[k]==pass时
                          f(arr,k-1,pass,to,from)+1<<k; arr[k]==to时
    当arr[k]==from时，证明第k个盘子没有移动，前k-1盘子正在从from移动到pass
    当arr[k]==pass时，证明第k个盘子在中间塔上，显然arr的数据不合理，全部返回-1
    当arr[k]==to时，  证明第k个盘子在目标塔上，其前面的k-1个盘子肯定需要移动到中间塔上，再把第k个盘子移到目标塔，花的次数就是2^k -1+1,于是这个阶段肯定花了1<<k步，然后再加上求k-1个盘子从to移动到from上的次数
    算法实现：
    import java.util.*;
	public class Hanoi {
	    private static final int LEFT_FLAG=1;
	    
	    private static final int MID_FLAG=2;
	    
	    private static final int RIGHT_FLAG=3;
	    
	    //汉诺塔问题是要将n个圆盘从左移到右 圆盘大小随着i的增大而增大
	    public int chkStep(int[] arr, int n) {
	        if(arr==null||arr.length!=n){
	            return -1;
	        }
	        return chk(arr,n-1,LEFT_FLAG,RIGHT_FLAG,MID_FLAG);
	    }
	    //按照盘子从大到小的顺序反向推导 chk方法求将k个盘子从from移动到to情况下，移动到arr状态下需要的次数，k从0开始
	    private int chk(int []arr,int k,int from,int to,int pass){
	        //如果k==-1代表没有盘子还需要计算
	        if(k==-1){
	            return 0;
	        }
	        //如果当前的盘子在中间位置，这是不可能的
	        if(arr[k]==pass){
	            return -1;
	        }
	        //如果当前的盘子在起始位置,证明这个盘子没有移动，前面的盘子正处于从起始位置移动到中间位置的过程
	        else if(arr[k]==from){
	            return chk(arr,k-1,from,pass,to);
	        }
	        //如果当前的盘子在终点位置
	        else if(arr[k]==to){
	            //前面的盘子肯定必须首先移动到中间位置 这儿需要花费2的盘子数-1次方 
	            //实际上汉诺塔问题 移动次数就是2的n-1次方
	            //这个步骤我们无法模拟过程 因为发生在之前 直接计算次数
	            int pastCount=1<<k;
	            //我们再把前面的盘子从中间位置移动到目标位置
	            int temp=chk(arr,k-1,pass,to,from);
	            //还是需要校验前面的盘子移动是否有问题
	            return temp==-1?-1:temp+pastCount;
	        }
	        //不合理参数
	        else return -1;
	    }
	}
    算法分析：
    算法的时间复杂度为O(n),空间复杂度为O(1)