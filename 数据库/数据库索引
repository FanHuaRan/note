数据库索引
个人理解
1.索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。
2.数据库索引提高了查询数据的效率，但降低了增删改数据的效率
3.索引分类
  (1)直接创建索引和间接创建索引
     直接创建索引:通过CREATE INDEX语句显式创建的索引
     间接创建索引:定义主键约束或者唯一性键约束时会间接创建索引
  (2)普通索引和唯一性索引
     普通索引:一般的索引
     唯一性索引:保证在索引列中的全部数据是唯一的，对聚簇索引和非聚簇索引都可以使用，主键索引是特殊的唯一性索引，不过唯一性索引准许null值
  (3)单个索引和复合索引
     单个索引：即非复合索引，只含有一个字段
     复合索引：又叫组合索引，在索引建立语句中同时包含多个字段名，最多16个字段
  (4)聚簇索引和非聚簇索引
     聚簇索引:又叫聚集索引或者说物理索引，与基表的物理顺序相同，数据值的顺序总是按照顺序排列
     非聚簇索引:非聚集索引
4.注意
  (1)一个表只能够建一个聚集索引
  (2)聚集索引+复合索引结合使用时，在查询当中，只要是使用到了索引字段的前排且不跳跃字段，都能够起到索引的作用
5.数据库索引依靠红黑树数据结构完成
原文
地址：http://www.360doc.cn/article/8053335_173037681.html
　一、索引的概念
索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。
二、索引的特点
1.索引可以加快数据库的检索速度
2.索引降低了数据库插入、修改、删除等维护任务的速度
3.索引创建在表上，不能创建在视图上
4.索引既可以直接创建，也可以间接创建
5.可以在优化隐藏中，使用索引
6.使用查询处理器执行SQL语句，在一个表上，一次只能使用一个索引
7.其他
三、索引的优点
1.创建唯一性索引，保证数据库表中每一行数据的唯一性
2.大大加快数据的检索速度，这也是创建索引的最主要的原因
3.加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。
4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。
5.通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。
四、索引的缺点
1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加
2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大
3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度
五、索引分类
1.直接创建索引和间接创建索引
直接创建索引： CREATE INDEX mycolumn_index ON mytable (myclumn)
间接创建索引：定义主键约束或者唯一性键约束，可以间接创建索引
2.普通索引和唯一性索引
普通索引：CREATE INDEX mycolumn_index ON mytable (myclumn)
唯一性索引：保证在索引列中的全部数据是唯一的，对聚簇索引和非聚簇索引都可以使用
CREATE UNIQUE COUSTERED INDEX myclumn_cindex ON mytable(mycolumn)
3.单个索引和复合索引
单个索引：即非复合索引
复合索引：又叫组合索引，在索引建立语句中同时包含多个字段名，最多16个字段
CREATE INDEX name_index ON username(firstname,lastname)
4.聚簇索引和非聚簇索引(聚集索引，群集索引)
聚簇索引：物理索引，与基表的物理顺序相同，数据值的顺序总是按照顺序排列
CREATE CLUSTERED INDEX mycolumn_cindex ON mytable(mycolumn) WITH
ALLOW_DUP_ROW(允许有重复记录的聚簇索引)
非聚簇索引：CREATE UNCLUSTERED INDEX mycolumn_cindex ON mytable(mycolumn)
六、索引的使用
1.当字段数据更新频率较低，查询使用频率较高并且存在大量重复值是建议使用聚簇索引
2.经常同时存取多列，且每列都含有重复值可考虑建立组合索引
3.复合索引的前导列一定好控制好，否则无法起到索引的效果。如果查询时前导列不在查询条件中则该复合索引不会被使用。前导列一定是使用最频繁的列
4.多表操作在被实际执行前，查询优化器会根据连接条件，列出几组可能的连接方案并从中找出系统开销最小的最佳方案。连接条件要充份考虑带有索引的表、行数多的表；内外表的选择可由公式：外层表中的匹配行数*内层表中每一次查找的次数确定，乘积最小为最佳方案
5.where子句中对列的任何操作结果都是在sql运行时逐列计算得到的，因此它不得不进行表搜索，而没有使用该列上面的索引；如果这些结果在查询编译时就能得到，那么就可以被sql优化器优化，使用索引，避免表搜索(例：select * from record where substring(card_no,1,4)=’5378’
&& select * from record where card_no like ’5378%’)任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边
6.where条件中的’in’在逻辑上相当于’or’，所以语法分析器会将in ('0','1')转化为column='0' or column='1'来执行。我们期望它会根据每个or子句分别查找，再将结果相加，这样可以利用column上的索引；但实际上它却采用了"or策略"，即先取出满足每个or子句的行，存入临时数据库的工作表中，再建立唯一索引以去掉重复行，最后从这个临时表中计算结果。因此，实际过程没有利用column上索引，并且完成时间还要受tempdb数据库性能的影响。in、or子句常会使用工作表，使索引失效；如果不产生大量重复值，可以考虑把子句拆开；拆开的子句中应该包含索引
7.要善于使用存储过程，它使sql变得更加灵活和高效
索引使用原则：
1、使用索引来更快地遍历表。
缺省情况下建立的索引是非群集索引，但有时它并不是最佳的。在非群集索引下，数据在物理 上随机存放在数据页上。合理的索引设计要建立在
对各种查询的分析和预测上。一般来说：
a.有大量重复值、且经常有范围查询（ > ,< ，> =,< =）和order by、group by发生的列，可考
虑建立群集索引；
b.经常同时存取多列，且每列都含有重复值可考虑建立组合索引；
c.组合索引要尽量使关键查询形成索引覆盖，其前导列一定是使用最频繁的列。索引虽有助于提高性能但不是索引越多越好，恰好相反过多的索引会导致系统低效。用户在表中每加进一个索引，维护索引集合就要做相应的更新工作。
2、在海量查询时尽量少用格式转换。
3、ORDER BY和GROPU BY使用ORDER BY和GROUP BY短语，任何一种索引都有助于SELECT的性能提高。
7、任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询时要尽可能将操作移至等号右边。
4、IN、OR子句常会使用工作表，使索引失效。如果不产生大量重复值，可以考虑把子句拆开。拆开的子句中应该包含索引。
Sql的优化原则2：
1、只要能满足你的需求，应尽可能使用更小的数据类型：例如使用MEDIUMINT代替INT
2、尽量把所有的列设置为NOT NULL，如果你要保存NULL，手动去设置它，而不是把它设为默认值。
3、尽量少用VARCHAR、TEXT、BLOB类型
4、如果你的数据只有你所知的少量的几个。最好使用ENUM类型
5、正如graymice所讲的那样，建立索引。
以下是我做的一个实验，可以发现索引能极大地提高查询的效率：
我有一个会员信息表users，里边有37365条用户记录：
在不加索引的时候进行查询：
sql语句A:
select * from users where username like ’%许%’;
在Mysql-Front中的8次查询时长为：1.40,0.54,0.54,0.54,0.53,0.55,0.54 共找到960条记录
sql语句B:
select * from users where username like ’许%’;
在Mysql-Front中的8次查询时长为：0.53,0.53,0.53,0.54,0.53,0.53,0.54,0.54 共找到836条记录
sql语句C:
select * from users where username like ’%许’;
在Mysql-Front中的8次查询时长为：0.51,0.51,0.52,0.52,0.51,0.51,0.52,0.51 共找到7条记录
为username列添加索引:
create index usernameindex on users(username(6));
再次查询：
sql语句A:
select * from users where username like ’%许%’;
在Mysql-Front中的8次查询时长为：0.35,0.34,0.34,0.35,0.34,0.34,0.35,0.34 共找到960条记录
sql语句B:
select * from users where username like ’许%’;
在Mysql-Front中的8次查询时长为：0.06,0.07,0.07,0.07,0.07,0.07,0.06,0.06 共找到836条记录
sql语句C:
select * from users where username like ’%许’;
在Mysql-Front中的8次查询时长为：0.32,0.31,0.31,0.32,0.31,0.32,0.31,0.31 共找到7条记录
在实验过程中，我没有另开任何程序，以上的数据说明在单表查询中，建立索引的可以极大地提高查询速度。
另外要说的是如果建立了索引，对于like ’许%’类型的查询，速度提升是最明显的。因此，我们在写sql语句的时候也尽量采用这种方式查询。
对于多表查询我们的优化原则是：
尽量将索引建立在：left join on/right join on ...　＋条件，的条件语句中所涉及的字段上。
多表查询比单表查询更能体现索引的优势。
6、索引的建立原则：
如果一列的中数据的前缀重复值很少，我们最好就只索引这个前缀。Mysql支持这种索引。我在上面用到的索引方法就是对username最左边的6个字符进行索引。索引越短，占用的
磁盘空间越少，在检索过程中花的时间也越少。这方法可以对最多左255个字符进行索引。
在很多场合，我们可以给建立多列数据建立索引。
索引应该建立在查询条件中进行比较的字段上，而不是建立在我们要找出来并且显示的字段上
7、限制索引的使用的避归。
7.1  IN、OR子句常会使用工作表，使索引失效。
如果不产生大量重复值，可以考虑把子句拆开。拆开的子句中应该包含索引。这句话怎么理解决，请举个例子
例子如下:
如果在fields1和fields2上同时建立了索引，fields1为主索引
以下sql会用到索引
select * from tablename1 where fields1=’value1’ and fields2=’value2’
以下sql不会用到索引
select * from tablename1 where fields1=’value1’ or fields2=’value2’
7.2 使用IS NULL 或IS NOT NULL
使用IS NULL 或IS NOT NULL同样会限制索引的使用。因为NULL值并没有被定义。在SQL语句中使用NULL会有很多的麻烦。因此建议开     发人员在建表时，把需要索引的列设成NOT NULL。如果被索引的列在某些行中存在NULL值，就不会使用这个索引（除非索引是一个位图索引，关于位图索引在稍后在详细讨论）。
7.3 使用函数
如果不使用基于函数的索引，那么在SQL语句的WHERE子句中对存在索引的列使用函数时，会使优化器忽略掉这些索引。下面的查询不会使用索引（只要它不是基于函数的索引）
select empno,ename,deptno
from   emp
where  trunc(hiredate)='01-MAY-81';
把上面的语句改成下面的语句，这样就可以通过索引进行查找。
select empno,ename,deptno
from   emp
where  hiredate<(to_date('01-MAY-81')+0.9999);
7.4 比较不匹配的数据类型
比较不匹配的数据类型也是比较难于发现的性能问题之一。注意下面查询的例子，account_number是一个VARCHAR2类型，在account_number字段上有索引。下面的语句将执行全表扫描。
select bank_name,address,city,state,zip
from   banks
where  account_number = 990354;
Oracle可以自动把where子句变成to_number(account_number)=990354，这样就限制了索引的使用,改成下面的查询就可以使用索引：
select bank_name,address,city,state,zip
from   banks
where  account_number ='990354';
特别注意：不匹配的数据类型之间比较会让Oracle自动限制索引的使用，即便对这个查询执行Explain Plan也不能让您明白为什么做了一               次“全表扫描”。
补充:
1.索引带来查询上的速度的大大提升,但索引也占用了额外的硬盘空间(当然现在一般硬盘空间不成问题),而且往表中插入新记录时索引也要随着更新这也需要一定时间.
有些表如果经常insert,而较少select,就不用加索引了.不然每次写入数据都要重新改写索引,花费时间;
这个视实际情况而定,通常情况下索引是必需的.
2.我在对查询效率有怀疑的时候,一般是直接用Mysql的Explain来跟踪查询情况.
你用Mysql-Front是通过时长来比较,我觉得如果从查询时扫描字段的次数来比较更精确一些.

参考文章
数据库索引的实现原理:http://user.qzone.qq.com/834171100/blog/1504108406 
数据库索引介绍及使用:http://www.360doc.cn/article/8053335_173037681.html
聚集索引和非聚集索引:http://blog.csdn.net/juststones/article/details/3023749