Effective java

第一章 对象的创建和销毁
1.考虑使用静态工厂替代构造函数
   好处：(1)静态工厂方法具有名字，更能表达意图
    	（2)每次被调用的时候，不要求非得创建一个新的对象
    	 (3)可以返回一个原返回类型的子类型的对象
   坏处：(1)类如果不含有共有的或者受保护的构造方法，就无法被子类化
   		 (2)静态工厂与其他构造方法没有任何区别，不会被API文档标识出来

2.通过私有构造方法强化Singleton属性（如果一个类实现了序列化接口，那它就不是严格意义的单例，因为可以被反序列化，后面有解决此方法的途径）

3.通过私有构造函数强化不可实例化的能力
  只包含静态方法和静态域的类虽然有不好的名声（有人滥用来编写面向过程的程序），但是这是有存在价值的：
  (1)可以把操作在基本类型和数组类型上的相关方法组织起来，java.util.Arrays
  (2)可以把操作在实现特定接口上的对象的方法组织起来，java.utils.Collections
  (3)把操作在final上的类的方法组织起来，以取代扩展该类的做法
  (4)工具类，utils，其实上面的都是
  这种类实例化是没有意义的，因此最好将它构造方法私有化，定义成抽象类是不可行的（可以被子类化或者给使用者造成困惑）

4.避免创建重复的对象(字符串和运行时常量池就是这个概念)
  注意：1.除了重用非可变的对象之外，对于那些已知不会被修改的课改变对象也可以使用此方法
  		2.不要滥用，慎重考虑，因为有些情况下会让代码更复杂，且JVM的垃圾回收是很强大的，尽量在重型对象上使用此方法

5.消除过期的对象引用
  java程序虽然存在垃圾回收机制，但是也会存在内存泄露问题（参照示例中的自定义stack）。注意一旦对象的引用过期（不会再使用它），需要清空引用（清空引用可以避免下一次错误使用而不产生空指针异常）
  警惕内存泄露的情况:
  (1)一个类自己管理内存！
  (2)缓存 补充weakhashmap知识

6.避免使用终结函数
  finalizer通常不可预测，常常比较危险，会导致不稳定行为，更差的性能和移植性问题，应该尽量避免使用析构函数。
  释放资源尽量显示释放
  需要使用终结函数的情况：
  (1)作为安全网
  (2)终止非关键的本地资源(对等体)
  注意如果要使用终结函数，注意子类需要显示调用父类的终结函数，它不像构造方法一样会缺省调用父类的终结方法

---------------------------------------------------------------------------------------------------------------

第二章.对于所有对象都通用的方法
7.在改写equals方法时请遵守通用约定
  在如下情况时不改写equals方法：
  (1)一个类的实例本质上是唯一的。比如Thread这种代表活动实体，而不是值的类
  (2)不关心一个类是否提供了"逻辑相等"的测试功能。
  (3)超类已经改写了equals,从超类继承过来的行为对于子类也是正确的。比如HashSet和AbstractSet,ArrayList和AbstractList
  (4)一个类是私有的或者是包级私有的，并且可以确定equals方法永远也不会被调用。这个情况最好还是改写，哪怕就是抛出UnsupportOperationException异常
  如下情况应该改写equals方法
  (1)一个类有自己特有的"逻辑相等"概念，不能使用引用相等来比较
  (2)超类也没有改写equals方法实现上面预期的行为
  改写equals方法的通用约定
  (1)自反性
  (2)对称性
  (3)传递性
  (4)一致性
  (5)对于任意的非空引用值x,x.equals(null)一定返回false 并不需要显示非空值判断
  实现高质量equals方法的处方和步骤
  (1)使用==操作符检查"实参是否为指向对象的一个引用"
  (2)使用instanceof操作符检查"实参是否为正确的类型"，补充还可以做非空值判断，null instanceof class是返回false
  (3)把实参转换到正确的类型
  (4)对于该类中的每一个"关键域"，检查实参中的域与当前对象中的域值是否匹配。域的比较顺序可能会影响性能，先比较最不可能相等的域
  注意事项：
  (1)改写equals方法，总是要改写hashcode
  (2)不要试图让equals方法过于聪明
  (3)不要使equals方法依赖于不可靠的资源
  (4)不要将equals方法中的参数类型从object修改为其它类型，这是重载，不是重写！

8.改写equals方法，总是且必须要改写hashcode
  改写hashcode方法的约定：
  (1)如果一个对象的equals方法做比较所用到的信息没有被修改的话，那么该对象调用hashcode方法多次，必须始终返回同一个整数
  (2)如果两个对象根据equals方法比较是相等的，那么两个对象的hashcode相等
  (3)如果两个对象根据equals方法是不相等的，不要求产生不一样的hashcode,但是如果能不同，有可能能够提升hashtable的性能
   改写equals方法而不改写hashcode方法主要违反了第二条
   实现高质量hashcode方法的处方和步骤
   1.把某个非零常数值保存在一个叫做result的int类型的变量中
   2.对于对象中的每一个关健域f(指equals方法中考虑的每一个域)，完成以下步骤：
   	 (1)如果该域是boolean类型，计算f?0:1;
   	 (2)如果该域是byte、char、short或者int类型，计算(int)f;
   	 (3)如果该域是long类型，则计算(int)f>>>32;
   	 (4)如果该域是float类型，则计算Float.floatToIntBits(f);
   	 (5)如果该域是double类型，则计算Double.doubleToLongBits(f);
   	 (6)如果该域是long类型，则计算(int)f>>>32;
   	 (7)如果该域是对象引用，并且该类的equals方法通过递归调用equals方法来比较这个域，则调用该域的hashcode，如果对象是null，那就为0
   	 (8)如果该域是数组，则依次对数组的每个元素做上述处理
   3.按照下面的公式，把a中的每个域的值组合到result当中
     result=result*31+c;
   4.返回result
   注意：如果一个类是非可变，并且计算散列码的代价比较大，考虑把散列码缓存在对象内部
   		 不要试图从散列码计算中排除掉一个对象的关键部分以提升性能

9.总是要改写toString()
  Object.toString提供了toString的实现：类名:@十六进制hashcode
  一个好的toString实现可以让类使用起来更加愉快，toString方法应该返回对象包含的所有令人感兴趣的信息

10.谨慎的改写clone
   cloneable接口的目的是作为对象的一个mixin接口，表明这样的对象准许克隆，object类本身就含有一个受保护的本地clone方法，在没有实现cloneable接口的情况下，调用clone方法会抛出ClassNotSuppport异常
   clone一定要减少使用，且注意深克隆和浅克隆

11.考虑实现Comparable接口
   一个类如果实现Comparable接口，可以使用Arrays,Collections方法的自然排序，并且和许多泛型方法以及依赖于该接口的集合实现进行协作，在java当中相关排序树TreeMap等都需要依靠此接口
   约定如下：
   (1)必须确保所有的x和y都满足sgn(x.compareTo(y)) == -sgn(y.compareTo(x))。这也暗示着当且仅当y.compareTo(x)抛出异常时，x.compareTo(y)才抛出异常。这条规则和equals使用规范里面的对称性类似。
   (2)必须确保这个比较关系是可传递的：(x.compareTo(y) > 0 && y.compareTo(z) > 0)暗示着x.compareTo(z) > 0也成立。对应着equals使用规范里面的传递性。
   (3)必须确保x.compareTo(y) == 0暗示着所有的z都满足sgn(x.compareTo(z)) == sgn(y.compareTo(z))。
   (4)强烈建议(x.compareTo(y) == 0) == (x.equals(y))，但是这个并非绝对必要。一般来说，任何实现了Comparable接口的类，若违反了这个条件，都应该明确予以说明。推荐使用这样的说法：“注意，该类具有内在的排序功能，但是与equals不一致”。

----------------------------------------------------------------------------------------------------------------

第七章 通用程序设计

29.将局部变量的作用域最小化
   (1)将局部变量的作用域最小化，可以增加代码的可读性和可维护性，并降低出错的可能性
   (2)将局部变量的作用域最小化，最有力的技术是在第一次使用它的地方声明
   (3)几乎每一个局部变量的声明都应该包含一个初始化表达式(try/catch除外)
   (4)for循环优于while循环，eg:
        for(Iterator i=c.iterator();i.hasNext();){
            doSomehing(i.next());
        }
      注意：对于支持随机访问的数据结构(数组和使用数组实现的集合)可以使用for迭代+索引访问，对于链表等结构不应该使用这种访问方式，因为会导致平方级的性能损耗。推荐如下方式：
        ArrayList list=.....;
        for(int i=0,n=list.size();i<n;i++){//减少重复调用size方法可以提高速度
            doSomehing(list.get(i));
        }
   (5)使方法小而集中

30.了解和使用库
   (1)通过使用标准库，可以充分利用这些编写标准库的专家的知识，以及前人的使用经验
   (2)在每一个主要的发行版本中，都会有许多新的特性被加入到库中，所以与这些库保证同步是值得的。
   (3)每一个java程序员都应该熟悉java.lang、java.util,某种程度上还有java.io中的内容。
      提一提Collecions Framework集合框架(六大接口：Collection,Set,List,Map,SortedSet,SortedMap,它们不是同级的)

31.如果要求精确的答案，请避免使用float和double.
   more://user.qzone.qq.com/834171100/blog/1505464490
   (1)float和double进行货币计算尤为不合适
   (2)尽量使用BigDecimal(尽量使用字符串初始化)，如果可以自己处理小数点，使用int（小数没有超过9位二进制数字）或者long（小数没有超过18位二进制数字），更大的只能使用bigDecimal
   (3)判断double和float也不能使用==

32.如果其它类型更适合，则尽量避免使用字符串
   (1)字符串不适合代替其它的值类型
   (2)字符串不适合代替枚举类型：类型安全枚举和int值都比字符串更加适合用来表示枚举类型的常量
   (3)字符串不适合替代聚集类型：莫使用字符串拼接，因为解析、处理特别麻烦，最好编写一个类(私有静态成员)
   (4)字符串也不适合替代能力表（即字符串不适合用于对某种功能进行授权访问）

33.了解字符串连接的性能
   (1)个字符串而重复地使用字符串连接操作符，要求n的平方级的时间
   (2)为了获得可接受的性能，尽量使用StrigBuilder(线程不安全)，StringBuffer(依靠synchronized方法实现的线程安全)

34.通过接口引用对象
   (1)如果有合适的接口存在，那么对参数、返回值、变量和域的声明都应该使用接口类型
   (2)如果养成了使用接口作为类型的习惯，那么程序将会更加灵活
   (3)有一点需要注意：如果原来的实现提供了某种特殊的性能，而这种功能并不是这个接口的通用约定所要求的，并且周围的代码又依赖于这种功能，那么很关键的一点是，新的实现（替换的实现）也要提供同样的功能，
   (4)如果没有合适的接口存在，那么，用类而不是接口来引用一个对象，是完全合适的,包括但是不限于以下几个情形：
      [1]值类(String,BigInteger,BigDecimal)直接使用类就OK
      [2]对象属于一个框架，但框架的基本类型是类，这个时候最好使用顶级的基类
      [3]一个类实现了一个接口，但是它提供了接口以外的方法且需要使用
    
    一句话：使用接口来引用对象的程序会更加灵活，如果不能通过接口引用，则使用类层次结构中提供了所需功能的最高层的类

35.接口先于映像(反射)机制
   (1)反射机制的坏处：（1）损失了编译时类型检查的好处
                    (2)要求执行映像访问的代码非常冗长
                    (3)性能损失
   (2)通常，普通应用在运行时刻不应该以映像方式访问对象
   (3)如果只是在很有限的情况下使用映像机制，那么虽然也会付出些许代价，但可以获得更大的好处
   (4)以映像方式创建对象，然后通过使用它们的接口或者超类以正常方式访问这些实例是比较nice的
   补充：对于类浏览器、对象监视器、代码分析工具、内嵌的解释器系统、框架实现（Springmvc、AOP），jdk代理等情况不得不使用反射

36.谨慎地使用本地方法
   尽可能少用本地方法，因为现代jvm足够快，并且使用本地方法有以下几个缺点：
   (1)本地方法不够安全
   (2)本地方法移植性比较差
   (3)调用和退出本地方法开销较大
   (4)本地代码的一个bug甚至可以终止jvm

37.谨慎地进行优化
  (1)不要因为性能而牺牲合理的结构，努力编写好的程序而不是快的程序
  (2)努力避免那些限制性能的设计决定
  (3)考虑API设计决定的性能后果
  (4)为了获得好的性能而对API进行曲改是非常不好的想法
  (5)每次试图做优化前和之后，请对性能进行测量
  一句话：设计的时候好好设计，努力提升性能和扩展性，后期尽量不为提升性能进行优化，可以重构！

38.遵守普遍接受的命名惯例
  不总结了，空间有日志，注意包的命名最好对单词使用缩写，不要太长！

----------------------------------------------------------------------------------------------------------------

第八章 异常
39.只针对不正常的条件才使用异常
   异常只应该被用于不正常的条件，它们永远不应该被用于正常的控制流。
   一个设计良好的API不应该强迫它的客户为了正常控制流而去使用异常。
   两种状态相关方法异常相关的设计方法：
   (1)状态测试方法，Iterator.next&Iterator.hasNext
   (2)可被识别的返回值，如null等
   指导原则：
   (1)如果一个对象会在缺少外部同步的情况下被并发访问，或者可以被外界改变状态，使用可被识别的返回值，因为并发当中状态可能改变了。
   (2)如果一个单独的状态测试方法必须要重复状态相关方法的工作，使用可被识别的返回值
   (3)其它情况为了可读性，优先使用状态测试方法。

40.对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常
   三种可抛出和捕获的结构：被检查的异常(Checked exception)、运行时异常(runtime exception)和错误(Error)
   选取原则:
   (1)如果期望调用者能够恢复，那么，对于这样的条件应该使用被检查的异常(API设计者让API用户面对一个检查型异常是在——提示用户与异常相关联的条件是调用这个方法的一种可能的成果，强制要求用户能从这个异常条件当中恢复，用户也可以捕获后直接忽略，不过这样不太好)
   (2)有两种未被检查的可抛出结构：运行时异常和错误，在行为上两者是等同的，都是不需要且不应该被捕获的抛出物！如果一个程序抛出运行时异常或者错误，往往这种情况是不可恢复的，继续执行有害无益！
   (3)使用运行时异常来指明程序错误(大部分运行时异常是明白前提违例，即API用户没有按规定使用API,这种一般是程序错误)
   (4)错误一般被JVM保留来用于指示资源不足，约束失败或者其他程序无法继续执行的条件，所以不要使用错误，自定义的未被检查的抛出结构应该是RuntimeException的子类。
   总之对于可恢复的条件使用被检查的异常，对于程序错误使用运行时异常，检查型异常最好包括相关获取异常信息的辅助方法。

41.避免不必要的使用被检查的异常
	对于检查型异常，如果正确使用API仍然会抛出异常且一旦产生了异常可以采取有用的动作，那么这对于程序员的负担是正常的，如果这两个条件不满足，那么选择使用运行时异常。
	把被检查的异常变成未被检查的异常的一种技术：把这个要抛出的异常的方法分成两个方法，其中一个方法返回boolean表明是否应该抛出异常。这是一种API转换，虽然可能不太合适，不过会让API用户更方便，参考39的状态测试。

42.尽量使用标准的异常
   java平台库提供了一组基本的未被检查的异常，它们覆盖了绝大多数API抛出异常的需要，我们尽量重用已有的异常。
   重用现有的异常的作用:
   (1)使API更加易于学习和使用，因为和我们一贯用法一致。
   (2)可读性更好，都是熟悉的异常
   (3)异常类越少，内存占用越小，装载这些类的时间的开销也更小，
   常用的非运行时异常：
	(1)IllegalArgumentException：参数非法
	(2)IllegalStateException：对于这个方法调用而言，对象状态不合适
	(3)NullPointerException: 在null被禁止的情况下参数值为null
	(4)IndexOutOfBoundException:下标越界
	(5)ConcurrentModifycationException:在禁止并发修改的情况下，对象检测到并发修改
	(6)UnsupportedOperaionException:对象不支持客户请求方法

43.抛出的异常要适合于相应的抽象
	高层的实现应该捕获低层的异常，同时抛出一个可以按照高层抽象进行解释的异常,这被称为异常转译(注意并不是总是适用)。
	一般套路：
	try{
		低层方法
	}catch(低层异常 e){
		throw new 高层异常;
	}
	最好使用异常链:
	try{
		低层方法
	}catch(低层异常 e){
		throw new 高层异常(e);
	}
	尽管异常转译比不加选择地传递低层异常的做法有所改进，但是它也不能被滥用，
	注意：底层应该尽量保证异常不产生，如果无法阻止底层的异常，让高层来处理异常，从而将高层方法的调用者，与低层的问题分开，异常抛出的两个指导意见：
	(1)如果既不能阻止来自底层的异常，也无法将他们与高层隔离开，使用异常转译。
	(2)底层所抛出的异常对于高层也是合适的，可以将异常传递到高层。

44.每个方法被抛出的异常都应该有文档
   多看看jdk源码就明白了，还是记下来
   (1)总是要单独地声明被检查的异常，并且利用javadoc的@throws标记，准确记录下每个异常被抛出的条件(包括检查型饿运行时)
   (2)使javadoc的@throws标签记录下一个方法可能会抛出的每个未被检查的异常，但是不要使用throws关键字将未被检查的异常包含在方法的声明中
   (3)如果一个类中的许多方法由于同样的原因而抛出同一个异常，那么在该类的文档注释中堆这个异常做文档，而不是为每个方法做文档是可以接受的。

45.在细节信息总包含失败-捕获信息
   重写toString方法，让其包含错误信息，从而可以让编译器自动打印出错误信息
   //实际上Throwable基类已经重写了toString方法可以打印一些细节，
   //对这个不满的时候，我们直接对其进行改写。
      public String toString() {
        String s = getClass().getName();
        String message = getLocalizedMessage();
        return (message != null) ? (s + ": " + message) : s;
    }

46.努力让失败保持原子性
  一般而言，一个失败的方法调用应该使对象保持在"它被调用之前的状态"，具有这种属性的方法被称为具有失败原子性。
  个人感觉就是ACID中的A原子性，C一致性
  获得失败原子性的途径：
  (1)设计不可变对象
  (2)在可变对象上，在执行操作之前检查参数的有序性，使得对象状态修改以前，异常就被抛出
  (3)对计算处理过程调整顺序，使得任何可能会失败的计算部分都发生在对象状态修改之前。
  (4)编写一段恢复代码，不常用，主要用于永久性的数据结构
  (5)在对象的临时拷贝上执行操作，当操作完成时，将临时拷贝的结果复制给原来的对象，eg:Collections.sort
  尽量让失败保持原子性，虽然还是有很多API没办到，办不到也要在文档中进行说明

47.不要忽略异常
   空的catch块会使异常达不到应有的目的，至少catch块也应该包括一条说明，用来解释为什么忽略掉这个异常是合适的。
   catch中尽量处理异常，在有足够的理由可以不管这个异常时，加一条说明。

----------------------------------------------------------------------------------------------------------------
	
第九章 线程
48.对共享可变数据的同步访问
   同步的理解：(1)一种互斥的方式，当一个对象被一个线程修改的时候，可以阻止另外一个线程观察到内部不一致的状态。
   			   (2)同步还可以保证一系列看似顺序执行的状态转变序列，对象从一种一致的状态变迁到另一种一致的状态。
   简单的说，无论何时当多个线程共享可变数据时，每个读或者写的线程必须获得一把锁。（读与读之间不用同步，读与写，写与写之间必须互斥）
   补充：在单例当中，双重检查往往不能很好的工作，因为可能另外一个线程会或取到一个不完整的对象，最好直接初始化或者使用内部类！

49.避免过多的同步
   (1)为了避免死锁的危险，在一个被同步的方法或者代码块当中，永远不要放弃对客户的控制：在一个被同步的区域内部，不要调用一个可被改写或者受保护的方法(这样的方法往往是抽象的)，该同步区域不知道这个方法会做什么事情，因此极有可能引起死锁。
   (2)在同步区域之外被调用的外来方法叫做开放调用，可以避免死锁和增加并发性。
   (3)通常，在同步区域内做尽可能少的工作。一般就是获得锁，检查共享数据，根据需要转换数据，释放锁。如果必须执行耗时的工作，考虑把该动作移到同步区域外(个人感觉本地IO操作是个例外)

50.永远不要在循环的外部调用wait
	Object.wait方法用于在同步块当中使一个线程等待某个条件。下面是使用wait方法的标准模式：
	Synchronized(obj){
		while(等待条件|不能持有锁的条件){
			obj.wait();
		}
		//////do some thing
	}
	总是使用wait循环模式来调用wait方法，永远不要在循环的外部调用wait，循环被用于在等待的前后检查条件(个人感觉wait调用无条件就不用了while了，或者作者是想让我们调用wait一定要检查条件？)，
	下面的理由会让一个线程醒过来：
	(1)另外一个线程可能得到了锁，并且在该线程调用notify的时刻，在等待线程醒过来的时刻之间，得到锁的线程已经改变了状态
	(2)条件并没有成立，但是另外一个线程恶意的调用了notify方法，这通常是公共锁！
	(3)通知线程在唤醒等待线程时可能过度大方，比如即使只有某一些等待的线程的条件已经被满足，但是通知线程还是必须调用nofityall
	(4)在没有被通知的情况下等待线程也可能醒过来，伪唤醒。
	(5)wait超时或者被interrupt后竞争到了线程锁，后者会抛出InterruptException.

	相关话题：为了唤醒正在等待的线程，应该使用notify还是notifyAll?
	(1)假设所有的wait调用都在while循环的内部，使用notifyAll是合理而保守的选择，程序总是能保证正确的结果，因为有循环检查保证正确性
	(2)一种优化措施，如果处于等待状态的所有线程都在等待同一个条件，而每次只有一个线程可以从这个条件中被唤醒，那使用notify.
	(3)无论何种情况，调用notifyall都是有意义的，就好像把wait放在循环条件中一样，notifyall可以避免相关线程的意外或者恶意等待，这种线程会吞掉唤醒通知，使得真正等待的线程一直等待，所以我们尽量使用内部私有锁。
	(4)使用notifyAll不会影响正确性，但会影响性能。会把等待线程数的线性级退化到平方级，假设有N个线程等待唤醒，那么notify一般就是唤醒N次。而notifyAll需要唤醒n+n-1+n-2+...+1次。
	(5)承接4.如果等待的线程数过多，此情况必须考虑效率，或者竞争某个特定状态的所有线程的逻辑是等价的，那就需要使用notify来精心设计唤醒策略

	总结：总是在while循环内部使用wait,使用notifyall可以保证正确性，但是会降低性能，使用notify可以提升性能，但是需要好好进行设计。

51.不要依赖于线程调度器
	当有多个线程可以运行时，线程调度器决定哪个线程将会运行，以及运行多长时间，线程调度器是jvm底层的组件。
	任何依赖于线程调度器而达到正确性或者性能要求的程序，很有可能是不可移植的。
	编写健壮，高性能的多线程程序是确保任何给定时刻只有少量的可运行线程。（多依靠wait,notifynotifyall，而不让线程忙等性能会更高）
	不要企图使用Thread.yield来"修正程序”，对于大多数程序员来说Thread.yield的唯一途径是测试期间人为的增加一个程序的并发性，对找出微妙的并发错误很有帮助
	线程优先级是最不可移植的特性，通过调整线程的优先级改善应用程序的响应能力，并非不合理，但这是不必要的。
	简单来说，不要让程序的正确性依赖于线程调度器。

52.线程安全性的文档化
	需要在一个类的文档中描述它的行为的并发性情况，如果不这样做，客户端可能会缺少足够的同步，或者过多的同步
	一个类为了可被多个线程并发的调用，必须在文档当中清楚的说明其所支持的线程的安全性级别。
	类的安全性级别如下：
	(1)非可变
	(2)线程安全
	(3)有条件的线程安全，比如HashTable和Vector的方法线程安全，但是他们的迭代器要求外部同步
	(4)线程兼容，在方法调用的外部使用同步可以确保线程安全，比如ArrayList和HashMap
	(5)线程对立，该类不能被安全的在多个线程中并发调用，即使外部加了锁，通过情况下是这个类的方法需要修改静态数据，而该静态数据可能会影响其它线程，这种情况非常少，比如System.runFinalizerOnExit

53.避免使用线程组
   线程组(ThreadGroup)是一个基本的抽象，可以统一管理一组线程，但是没有提供多少实用的功能，或者带来任何的提升安全性的作用。线程组基本已经过时。如果需要考虑使用线程组，那么使用数组或者集合代替可能更好。
   有一个例外，如果想统一给一组线程设置异常处理：ThreadGroup.unCaughtException会有很多作用、

