个人理解
1.Hash表是一种特殊的数据结构，它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。这个源于Hash表设计的特殊性，它采用了函数映射的思想将记录的存储位置与记录的关键字关联起来，从而能够很快速地进行查找。
2.Hash表的根本原理是
  (1)先建立一个存储记录的容器，这个容器必须是具有随机读能力的线性表(即数组，链表法在一维也是数组)
  (2hash表的存储与查找都是通过一个映射函数 f : key —> address,这个称之为hash函数,存储时通过该记录关键字的进行hash函数运算获取到它在容器中的存储地址后直接存储,查找时通过关键字进行hash函数运算获取到地址后就直接去地址取记录
比如:
java中的hashtable通过key的hashcode对容器长度取模 从而得到一个容器当中的索引，即是存储位置
hashmap是通过hashcode重新计算hash值，然后使用与运算获取索引,再与长度进行取模计算
4.hash函数：hash函数就是将key->hash表中的地址的一个运算函数，即index=hash(key)
5.java当中对象的hashcode(哈希码)方法不是hash函数，而是一个构造对象的key的函数，真正的hash函数就是hashmap里面的容器取模运算的那个函数，实际上java中的hash冲突不仅指对象hashcode相同，还包括hashcode不同但通过hash计算的位置相同的情况，所以hashcode只相当于hash数据结构中的key
6.什么叫hash冲突：hash冲突是指两个待存储元素通过hash函数计算出来的存储位置相同，这一方面是由于对象的hashcode相同，另外一方面是由于对象的hashcode不同但hash函数计算的位置相同
7.hash冲突的解决：因为hash函数始终不是唯一的，所以可能会出现两个记录要存储到同一个地址的情况，有如下几种策略解决hash冲突：
[1]开放地址法（包括多个探测方法按照一定规则去寻找合适的地址，如果是查找的话，也是一样，不过同时会比较key）
[2]链表法（每个通过hash函数计算的位置相同的元素存储在链表中，链表内部比较key(HashMap中Key的HashCode)和value(HashMap中的Key)，或者将链表修改为红黑树可以提高比较查找的效率）
[3]再散列
[4]建立公共溢出区 
注意：
    java解决hash冲突基本都是使用的链表法
    开哈希表-------链式地址法
    闭哈希表-------开放地址法
8.Hash表的平均查找长度包括查找成功时的平均查找长度和查找失败时的平均查找长度。
　　查找成功时的平均查找长度=表中每个元素查找成功时的比较次数之和/表中元素个数；
查找不成功就是从查找位置开始直到一个位置为空需要比较的次数。其平均长度就是从容器的每个位置及之后查找到null位置的比较次数之和/表长，也可以下面这样理解：
　　查找不成功时的平均查找长度相当于在表中查找元素不成功时的平均比较次数，可以理解为向表中插入某个元素，该元素在每个位置都有可能，然后计算出在每个位置能够插入时需要比较的次数，再除以表长即为查找不成功时的平均查找长度。
9.hash冲突的解决 暴雪公司有一个新方法，使用三个hash值，一个求位置，两个比较值，冲突时，依次向后比较
原文
1.Hash表：http://www.cnblogs.com/dolphin0520/archive/2012/09/28/2700000.html
2.解决Hash冲突的几种方法：http://blog.csdn.net/u012104435/article/details/47951357